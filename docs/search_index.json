[
["index.html", "Extracting grid cell coverages of geospatial layers Chapter 1 Introduction", " Extracting grid cell coverages of geospatial layers Tim P. Lenters 2020-08-14 Chapter 1 Introduction This Bookdown document explains how to extract the proportion of coverage by each class for a specified grid. These scripts are useful for large (global) layers as most calculations run in parallel. This is done by integrating SAGA and GDAL console commands in each script. Input spatial files can be either vector or grid layers. This analysis is done for five different geospatial layers. This document consists of several chapters: How to install SAGA and GDAL Making a Goode Homolosine grid Calculating coverages for: Global Lithological map (GLiM) Global River Classification (GloRiC) Global Lakes and Wetlands Database (GLWD) Global terrain classification (Iwahashi et al., 2018) World Reference Base Soil Groups (SoilGrids) Aggregating all value tables "],
["install-saga-and-gdal.html", "Chapter 2 Install SAGA and GDAL 2.1 GDAL 2.2 SAGA", " Chapter 2 Install SAGA and GDAL This chapter shows how to install SAGA and GDAL on Windows for parallel computing through R. 2.1 GDAL This software tool is used for handling spatial data and is especially useful for exchanging/converting spatial data. To install GDAL on Windows go to http://www.gisinternals.com/release.php, click release-1900-x64-gdal-2-4-4-mapserver-7-4-3 and download gdal-204-1900-x64-core.msi. Follow installation steps via GDAL-installer. GDAL can be called from the command line in Rstudio. They can be linked by running this script on both Windows and Unix-systems: if(.Platform$OS.type == &quot;windows&quot;){ gdal.dir &lt;- shortPathName(&quot;C:/Program files/GDAL&quot;) gdal_translate &lt;- paste0(gdal.dir, &quot;/gdal_translate.exe&quot;) gdalwarp &lt;- paste0(gdal.dir, &quot;/gdalwarp.exe&quot;) } else { gdal_translate = &quot;gdal_translate&quot; gdalwarp = &quot;gdalwarp&quot; } system(paste(gdalwarp, &quot;--help&quot;)) #If done correctly, this will give help menu Other functions and their directory can be added in the ‘if’-statement to use them. These can be found in the GDAL folder in Program Files. 2.2 SAGA This program provides comprehensive GIS geoprocessing software with over 600 functions. To install, go to https://sourceforge.net/projects/saga-gis/ and download SAGA GIS by clicking the green button. Follow installation steps via SAGA-installer (7.6.3 is preferred). SAGA GIS can also be called from the command line in Rstudio. They can be linked by running this script on both Windows and Unix-systems: if(Sys.info()[&#39;sysname&#39;]==&quot;Windows&quot;){ saga_cmd = &quot;C:/#specify location here/saga_cmd.exe&quot; } else { saga_cmd = &quot;saga_cmd&quot; } system(paste(saga_cmd, &quot;-v&quot;)) #If installed correctly, this will give version Available functions and their command line arguments for your specific SAGA GIS version can be found here: http://www.saga-gis.org/saga_tool_doc/index.html. "],
["making-goode-homolosine-grid.html", "Chapter 3 Making Goode Homolosine grid 3.1 R-script", " Chapter 3 Making Goode Homolosine grid This chapter explains how to make a global grid in the Goode Homolosine projection. This grid has a cellsize of 10x10km. 3.1 R-script Packages are automatically installed (if needed) and loaded from library. list.of.packages &lt;- c(&quot;raster&quot;, &quot;rgdal&quot;, &quot;dplyr&quot;, &quot;data.table&quot;) new.packages &lt;- list.of.packages[!(list.of.packages %in% installed.packages()[,&quot;Package&quot;])] if(length(new.packages)) install.packages(new.packages, dependencies = TRUE) library(raster) library(rgdal) library(dplyr) library(data.table) saga_cmd and gdal are linked to the R console. if(Sys.info()[&#39;sysname&#39;]==&quot;Windows&quot;){ saga_cmd = &quot;C:/Users/11026685/Downloads/saga-7.6.3_x64/saga-7.6.3_x64/saga_cmd.exe&quot; } else { saga_cmd = &quot;saga_cmd&quot; } system(paste(saga_cmd, &quot;-v&quot;)) #&quot;SAGA Version: 7.6.3 (64 bit)&quot; if succesful if(.Platform$OS.type == &quot;windows&quot;){ gdal.dir &lt;- shortPathName(&quot;C:/Program files/GDAL&quot;) gdal_translate &lt;- paste0(gdal.dir, &quot;/gdal_translate.exe&quot;) gdalwarp &lt;- paste0(gdal.dir, &quot;/gdalwarp.exe&quot;) } else { gdal_translate = &quot;gdal_translate&quot; gdalwarp = &quot;gdalwarp&quot; } system(paste(gdalwarp, &quot;--help&quot;)) #If done correctly, this will give help menu Working directory is set. setwd(&quot;D:/people/Tim/grid&quot;) Parameters are set. Goode Homolosine mask is specified. Cellsize, extent and desired projection are also set. gh.shp = &quot;input/Goode_Homolosine_domain.shp&quot; cellsize = 10000 te = c(-20037508,-8683260, 20037508, 8683260) gh.prj = &quot;+proj=igh +ellps=WGS84 +units=m +no_defs&quot; The mask shapefile is converted to a grid for the given cellsize. system(paste0(saga_cmd, &#39; -c=64 grid_gridding 0 -INPUT \\&quot;&#39;, gh.shp, &#39;\\&quot; -FIELD \\&quot;FID\\&quot; -GRID \\&quot;output/Goode_Homolosine_domain_10km.sgrd\\&quot; -GRID_TYPE 1 -TARGET_DEFINITION 0 -TARGET_USER_SIZE &#39;, cellsize, &#39; -TARGET_USER_XMIN &#39;, te[1]+cellsize/2,&#39; -TARGET_USER_XMAX &#39;, te[3]-cellsize/2, &#39; -TARGET_USER_YMIN &#39;, te[2]+cellsize/2,&#39; -TARGET_USER_YMAX &#39;, te[4]-cellsize/2)) .sgrd is converted to .tif. system(paste0(gdal_translate, &#39; output/Goode_Homolosine_domain_10km.sdat output/Goode_Homolosine_domain_10km.tif -a_srs \\&quot;&#39;, gh.prj, &#39;\\ -ot \\&quot;Byte\\&quot;&#39;)) A data frame with coordinates is made from the grid and cell ID is added. Coordinates specify the centroid of each grid cell. gh_grid &lt;- raster(&quot;output/Goode_Homolosine_domain_10km.tif&quot;) gh_grid_df &lt;- as.data.frame(gh_grid, xy=TRUE, centroids = TRUE, na.rm = TRUE) # Remove cells with no land coverage gh_grid_df$cell_ID &lt;- 1:nrow(gh_grid_df) This data frame is converted to a format to be used in Marxan. marxan_grid &lt;- gh_grid_df %&gt;% select(cell_ID, x, y) fwrite(marxan_grid, &quot;output/grid_table.csv&quot;, row.names = FALSE, sep=&quot;,&quot;, dec = &quot;.&quot; ) cell_ID x y 1 -11377492 8678260 2 -11367492 8678260 3 -11357492 8678260 … … … "],
["calculating-coverages.html", "Chapter 4 Calculating coverages 4.1 Global Lithological map (GLiM) 4.2 Global River Classification (GloRiC) 4.3 Global Lakes and Wetlands Database (GLWD) 4.4 Global terrain classification (Iwahashi et al., 2018) 4.5 World Reference Base Soil Groups (SoilGrids)", " Chapter 4 Calculating coverages In this chapter, coverages of five different spatial layers are calculated. The grid maded in the previous chapter is used as a template. 4.1 Global Lithological map (GLiM) Packages are automatically installed (if needed) and loaded from library. list.of.packages &lt;- c(&quot;rgdal&quot;, &quot;GSIF&quot;, &quot;raster&quot;, &quot;dplyr&quot;, &quot;spdplyr&quot;, &quot;data.table&quot;, &quot;reshape2&quot;, &quot;progress&quot;, &quot;tictoc&quot;) new.packages &lt;- list.of.packages[!(list.of.packages %in% installed.packages()[,&quot;Package&quot;])] if(length(new.packages)) install.packages(new.packages, dependencies = TRUE) if(!(&quot;dtraster&quot; %in% installed.packages()[,&quot;Package&quot;])) remotes::install_github(&quot;ldemaz/dtraster&quot;) library(rgdal) library(GSIF) library(raster) library(dplyr) library(spdplyr) library(data.table) library(dtraster) library(reshape2) library(progress) library(tictoc) A timer is set for the total calculation time and for each section seperately. tic.clearlog() tic(&quot;Total time&quot;) saga_cmd is linked to the R console. if(Sys.info()[&#39;sysname&#39;]==&quot;Windows&quot;){ saga_cmd = &quot;C:/Users/11026685/Downloads/saga-7.6.3_x64/saga-7.6.3_x64/saga_cmd.exe&quot; } else { saga_cmd = &quot;saga_cmd&quot; } system(paste(saga_cmd, &quot;-v&quot;)) #&quot;SAGA Version: 7.6.3 (64 bit)&quot; if succesful Working directory is set. setwd(&quot;D:/people/Tim/global&quot;) The shapefile is reprojected to Goode Homolosine. tic(&quot;Reproject to Goode Homolosine&quot;) system(paste0(saga_cmd, &#39; pj_proj4 2 -CRS_PROJ4 &quot;+proj=igh +ellps=WGS84 +units=m +no_defs&quot; -SOURCE &quot;input/shp.shp&quot; -TARGET &quot;input/shp_gh.shp&quot; -PARALLEL 1&#39;)) shp_gh &lt;- readOGR(dsn = &quot;input&quot;, layer = &quot;shp_gh&quot;, encoding = &quot;ESRI Shapefile&quot;) toc(log = TRUE) Due to overlapping layers (which led to coverages higher than 100%), duplicate layers are excluded. shp_gh &lt;- shp_gh %&gt;% distinct(IDENTITY_, .keep_all = TRUE) Parameters are set. This includes the tag for this dataset, the different classes and the grid. dataset_tag &lt;- &quot;GLiM&quot; classes &lt;- levels(shp_gh$Litho) gh_grid &lt;- &quot;D:/people/Tim/grid/output/Goode_Homolosine_domain_10km.tif&quot; For each class of the shapefile, coverages are calculated per grid cell. These values are converted to a dataframe, which are added to a data frame with the values of every class. # Data.table to append values to dt_total = data.table() # Set progress bar pb &lt;- progress_bar$new(total = length(classes),format = &quot;[:bar] :current/:total layers |:percent | :elapsedfull&quot;, width = 60) tic(&quot;Calculate coverage per type&quot;) for (i in 1:length(classes)){ # Progress bar pb$tick() Sys.sleep(1 / 100) # Make subset of different types shp_gh_subset &lt;- shp_gh[shp_gh$Litho == classes[i],] writeOGR(shp_gh_subset, paste0(&quot;analysis/&quot;,classes[i],&quot;.gpkg&quot;),paste0(&quot;type_&quot;,classes[i]),&quot;GPKG&quot;, overwrite_layer = TRUE) # Calculate polygon coverage per grid cell system(show.output.on.console = FALSE, paste0(saga_cmd, &#39; grid_gridding 8 -POLYGONS=\\&quot;analysis/&#39;,classes[i],&#39;.gpkg&quot; -AREA=\\&quot;analysis/&#39;,classes[i],&#39;.tif&quot; -TARGET_DEFINITION 1 -TARGET_TEMPLATE &#39;, gh_grid)) # Construct data.table with results type_raster &lt;- raster(paste0(&quot;analysis/&quot;,classes[i],&quot;.tif&quot;)) type_dt &lt;- as.data.table.raster(type_raster, xy = TRUE, centroids = TRUE, na.rm = TRUE) setnames(type_dt, classes[i], &quot;proportion&quot;) type_dt[,proportion := proportion/100] type_dt[,feature := paste(dataset_tag, classes[i], sep = &quot;_&quot;)] setcolorder(type_dt, c(&quot;x&quot;,&quot;y&quot;,&quot;feature&quot;,&quot;proportion&quot;)) type_dt[,area_km2 := 10^2 * proportion] dt_total &lt;- bind_rows(dt_total, type_dt) } toc(log = TRUE) The correct cell ID is added to each grid value. grid_table &lt;- fread(&quot;D:/people/Tim/grid/output/grid_table.csv&quot;, data.table = TRUE) ID_join &lt;- data.table::merge.data.table(grid_table, dt_total, by = c(&quot;x&quot;,&quot;y&quot;)) ID_join[,c(&quot;x&quot;,&quot;y&quot;) := NULL] The value table is saved and elapsed time is logged. fwrite(ID_join, file = paste0(&quot;output/&quot;,dataset_tag,&quot;_value_table.csv&quot;), row.names = FALSE, sep=&quot;,&quot;, dec = &quot;.&quot; ) toc(log = TRUE) # Time elapsed time_log &lt;- tic.log(format = TRUE) 4.2 Global River Classification (GloRiC) Packages are automatically installed (if needed) and loaded from library. list.of.packages &lt;- c(&quot;rgdal&quot;, &quot;sf&quot;, &quot;raster&quot;, &quot;dplyr&quot;, &quot;data.table&quot;, &quot;progress&quot;, &quot;tictoc&quot;) new.packages &lt;- list.of.packages[!(list.of.packages %in% installed.packages()[,&quot;Package&quot;])] if(length(new.packages)) install.packages(new.packages, dependencies = TRUE) if(!(&quot;dtraster&quot; %in% installed.packages()[,&quot;Package&quot;])) remotes::install_github(&quot;ldemaz/dtraster&quot;) library(rgdal) library(sf) library(raster) library(dplyr) library(data.table) library(dtraster) library(progress) library(tictoc) A timer is set for the total calculation time and for each section seperately. tic.clearlog() tic(&quot;Total time&quot;) saga_cmd is linked to the R console. if(Sys.info()[&#39;sysname&#39;]==&quot;Windows&quot;){ saga_cmd = &quot;C:/Users/11026685/Downloads/saga-7.6.3_x64/saga-7.6.3_x64/saga_cmd.exe&quot; } else { saga_cmd = &quot;saga_cmd&quot; } system(paste(saga_cmd, &quot;-v&quot;)) #&quot;SAGA Version: 7.6.3 (64 bit)&quot; if succesful Working directory is set. setwd(&quot;D:/people/Tim/global&quot;) The required field is selected (Reach_type) input_shp &lt;- &quot;input/GloRiC_v10.shp&quot; input_shp_del &lt;- &quot;input/GloRiC_v10_del.shp&quot; system(paste0(saga_cmd, &#39; table_tools 11 -TABLE &quot;&#39;,input_shp,&#39;&quot; -OUT_SHAPES &quot;&#39;,input_shp_del,&#39;&quot; -FIELDS 0,1,2,3,4,5,6,7,8,9,10,11,12,14&#39;)) The shapefile is reprojected to Goode Homolosine. input_shp_gh &lt;- &quot;input/GloRiC_v10_gh.shp&quot; tic(&quot;Reproject to Goode Homolosine&quot;) system(paste0(saga_cmd, &#39; pj_proj4 2 -CRS_PROJ4 &quot;+proj=igh +ellps=WGS84 +units=m +no_defs&quot; -SOURCE &quot;&#39;,input_shp_del,&#39;&quot; -TARGET &quot;&#39;,input_shp_gh,&#39;&quot; -PARALLEL 1&#39;)) toc(log = TRUE) “0” values are deleted (water). shp_gh &lt;- read_sf(input_shp_gh) shp_gh &lt;- dplyr::filter(shp_gh, Reach_type != 0) shp_gh$Reach_type &lt;- as.numeric(shp_gh$Reach_type) shp_gh &lt;- write_sf(shp_gh, input_shp_gh) Because the shapefile only contains Polylines, it is converted to a raster. input_raster &lt;- &quot;input/GloRiC_v10_gh_raster.tif&quot; tic(&quot;Rasterize shapefile&quot;) system(paste0(saga_cmd, &#39; grid_gridding 0 -INPUT &quot;&#39;,input_shp_gh,&#39;&quot; -GRID &quot;&#39;,input_raster,&#39;&quot; -FIELD &quot;Reach_type&quot; -TARGET_USER_SIZE 1000&#39;)) toc(log = TRUE) Grid coverages are calculated per class. output_types &lt;- &quot;analysis/GloRiC_v10_gh_.sgrd&quot; gh_grid &lt;- &quot;D:/people/Tim/grid/output/Goode_Homolosine_domain_10km.tif&quot; tic(&quot;Grid coverage per class&quot;) system(paste0(saga_cmd, &#39; grid_analysis 26 -CLASSES &quot;&#39;,input_raster, &#39;&quot; -COVERAGES &quot;&#39;,output_types,&#39;&quot; -TARGET_DEFINITION 1 -TARGET_TEMPLATE &quot;&#39;,gh_grid,&#39;&quot;&#39;)) toc(log = TRUE) Parameters are set. This includes the tag for this dataset and the different classes. A list of files is made for the coverages of all classes. type_list &lt;- list.files(path=&quot;analysis&quot;, pattern = &quot;^.*GloRiC_v10_gh_*.*.sgrd$&quot;, full.names = TRUE) dataset_tag &lt;- &quot;GloRiC&quot; classes &lt;- data.table(name = sort(unique(shp_gh$Reach_type)), type = gsub(&quot;analysis/|.sgrd&quot;,&quot;&quot;,type_list)) Grid values for all classes are added to one data frame. # Data.table to append values to dt_total = data.table() # Set progress bar pb &lt;- progress_bar$new(total = NROW(classes), format = &quot;[:bar] :current/:total layers |:percent | :elapsedfull&quot;, width = 60) tic(&quot;Construct table with coverages&quot;) for (i in 1:NROW(classes)){ # Progress bar pb$tick() Sys.sleep(1 / 100) # Construct data.table with results type_raster &lt;- raster(type_list[i]) type_raster[type_raster == 0] &lt;- NA type_dt &lt;- as.data.table.raster(type_raster, xy = TRUE, centroids = TRUE, na.rm = TRUE) setnames(type_dt, classes$type[i], &quot;proportion&quot;) type_dt[,feature := paste(dataset_tag, classes$name[i], sep = &quot;_&quot;)] setcolorder(type_dt, c(&quot;x&quot;,&quot;y&quot;,&quot;feature&quot;,&quot;proportion&quot;)) type_dt[,area_km2 := 10^2 * proportion] dt_total &lt;- bind_rows(dt_total, type_dt) } toc(log = TRUE) The correct cell ID is added to each grid value. grid_table &lt;- fread(&quot;D:/people/Tim/grid/output/grid_table.csv&quot;, data.table = TRUE) ID_join &lt;- data.table::merge.data.table(grid_table, dt_total, by = c(&quot;x&quot;,&quot;y&quot;)) ID_join[,c(&quot;x&quot;,&quot;y&quot;) := NULL] The value table is saved and elapsed time is logged. fwrite(ID_join, file = paste0(&quot;output/&quot;,dataset_tag,&quot;_value_table.csv&quot;), row.names = FALSE, sep=&quot;,&quot;, dec = &quot;.&quot; ) toc(log = TRUE) # Time elapsed time_log &lt;- tic.log(format = TRUE) 4.3 Global Lakes and Wetlands Database (GLWD) Packages are automatically installed (if needed) and loaded from library. list.of.packages &lt;- c(&quot;rgdal&quot;, &quot;sf&quot;, &quot;raster&quot;, &quot;dplyr&quot;, &quot;data.table&quot;, &quot;progress&quot;, &quot;tictoc&quot;) new.packages &lt;- list.of.packages[!(list.of.packages %in% installed.packages()[,&quot;Package&quot;])] if(length(new.packages)) install.packages(new.packages, dependencies = TRUE) if(!(&quot;dtraster&quot; %in% installed.packages()[,&quot;Package&quot;])) remotes::install_github(&quot;ldemaz/dtraster&quot;) library(rgdal) library(sf) library(raster) library(dplyr) library(data.table) library(dtraster) library(progress) library(tictoc) A timer is set for the total calculation time and for each section seperately. tic.clearlog() tic(&quot;Total time&quot;) saga_cmd is linked to the R console. if(Sys.info()[&#39;sysname&#39;]==&quot;Windows&quot;){ saga_cmd = &quot;C:/Users/11026685/Downloads/saga-7.6.3_x64/saga-7.6.3_x64/saga_cmd.exe&quot; } else { saga_cmd = &quot;saga_cmd&quot; } system(paste(saga_cmd, &quot;-v&quot;)) #&quot;SAGA Version: 7.6.3 (64 bit)&quot; if succesful Working directory is set. setwd(&quot;D:/people/Tim/global&quot;) The raster is reprojected to Goode Homolosine input_raster &lt;- &quot;input/glwd_3.tif&quot; input_gh &lt;- &quot;input/glwd_3_gh.tif&quot; tic(&quot;Reproject to Goode Homolosine&quot;) system(paste0(saga_cmd, &#39; pj_proj4 4 -CRS_PROJ4 &quot;+proj=igh +ellps=WGS84 +units=m +no_defs&quot; -SOURCE &#39;, input_raster,&#39; -GRID &#39;,input_gh,&#39; -RESAMPLING 0&#39;)) toc(log = TRUE) Grid coverages are calculated per class. output_types &lt;- &quot;analysis/glwd_3_gh_.sgrd&quot; gh_grid &lt;- &quot;D:/people/Tim/grid/output/Goode_Homolosine_domain_10km.tif&quot; tic(&quot;Grid coverage per class&quot;) system(paste0(saga_cmd, &#39; grid_analysis 26 -CLASSES &quot;&#39;,input_gh, &#39;&quot; -COVERAGES &quot;&#39;,output_types,&#39;&quot; -TARGET_DEFINITION 1 -TARGET_TEMPLATE &quot;&#39;,gh_grid,&#39;&quot;&#39;)) toc(log = TRUE) Parameters are set. This includes the tag for this dataset and the different classes. A list of files is made for the coverages of all classes. type_list &lt;- list.files(path=&quot;analysis&quot;, pattern = &quot;^.*glwd_3_gh_*.*.sgrd$&quot;, full.names = TRUE) dataset_tag &lt;- &quot;GLWD&quot; classes &lt;- data.table(name = sort(unique(shp_gh$Reach_type)), type = gsub(&quot;analysis/|.sgrd&quot;,&quot;&quot;,type_list)) Grid values for all classes are added to one data frame. # Data.table to append values to dt_total = data.table() # Set progress bar pb &lt;- progress_bar$new(total = NROW(classes), format = &quot;[:bar] :current/:total layers |:percent | :elapsedfull&quot;, width = 60) tic(&quot;Construct table with coverages&quot;) for (i in 1:NROW(classes)){ # Progress bar pb$tick() Sys.sleep(1 / 100) # Construct data.table with results type_raster &lt;- raster(type_list[i]) type_raster[type_raster == 0] &lt;- NA type_dt &lt;- as.data.table.raster(type_raster, xy = TRUE, centroids = TRUE, na.rm = TRUE) setnames(type_dt, classes$type[i], &quot;proportion&quot;) type_dt[,feature := paste(dataset_tag, classes$name[i], sep = &quot;_&quot;)] setcolorder(type_dt, c(&quot;x&quot;,&quot;y&quot;,&quot;feature&quot;,&quot;proportion&quot;)) type_dt[,area_km2 := 10^2 * proportion] dt_total &lt;- bind_rows(dt_total, type_dt) } toc(log = TRUE) The correct cell ID is added to each grid value. grid_table &lt;- fread(&quot;D:/people/Tim/grid/output/grid_table.csv&quot;, data.table = TRUE) ID_join &lt;- data.table::merge.data.table(grid_table, dt_total, by = c(&quot;x&quot;,&quot;y&quot;)) ID_join[,c(&quot;x&quot;,&quot;y&quot;) := NULL] The value table is saved and elapsed time is logged. fwrite(ID_join, file = paste0(&quot;output/&quot;,dataset_tag,&quot;_value_table.csv&quot;), row.names = FALSE, sep=&quot;,&quot;, dec = &quot;.&quot; ) toc(log = TRUE) # Time elapsed time_log &lt;- tic.log(format = TRUE) 4.4 Global terrain classification (Iwahashi et al., 2018) Packages are automatically installed (if needed) and loaded from library. list.of.packages &lt;- c(&quot;rgdal&quot;, &quot;sf&quot;, &quot;raster&quot;, &quot;dplyr&quot;, &quot;data.table&quot;, &quot;progress&quot;, &quot;tictoc&quot;) new.packages &lt;- list.of.packages[!(list.of.packages %in% installed.packages()[,&quot;Package&quot;])] if(length(new.packages)) install.packages(new.packages, dependencies = TRUE) if(!(&quot;dtraster&quot; %in% installed.packages()[,&quot;Package&quot;])) remotes::install_github(&quot;ldemaz/dtraster&quot;) library(rgdal) library(sf) library(raster) library(dplyr) library(data.table) library(dtraster) library(progress) library(tictoc) A timer is set for the total calculation time and for each section seperately. tic.clearlog() tic(&quot;Total time&quot;) saga_cmd is linked to the R console. if(Sys.info()[&#39;sysname&#39;]==&quot;Windows&quot;){ saga_cmd = &quot;C:/Users/11026685/Downloads/saga-7.6.3_x64/saga-7.6.3_x64/saga_cmd.exe&quot; } else { saga_cmd = &quot;saga_cmd&quot; } system(paste(saga_cmd, &quot;-v&quot;)) #&quot;SAGA Version: 7.6.3 (64 bit)&quot; if succesful Working directory is set. setwd(&quot;D:/people/Tim/global&quot;) Water is set as no-data value. full_raster &lt;- &quot;input/GlobalTerrainClassification_Iwahashi_etal_2018.tif&quot; crop_raster &lt;- &quot;input/Iwahashi.tif&quot; tic(&quot;Set water (0) as no-data&quot;) system(paste0(saga_cmd, &#39; grid_tools 15 -INPUT &#39;,full_raster,&#39; -RESULT &#39;,crop_raster,&#39; -NEW 0 -RESULT_NODATA_CHOICE 1 -RESULT_NODATA_VALUE 0&#39;)) toc(log = TRUE) The raster is reprojected to Goode Homolosine input_raster &lt;- &quot;input/Iwahashi.tif&quot; input_gh &lt;- &quot;input/Iwahashi_gh.tif&quot; tic(&quot;Reproject to Goode Homolosine&quot;) system(paste0(saga_cmd, &#39; pj_proj4 4 -CRS_PROJ4 &quot;+proj=igh +ellps=WGS84 +units=m +no_defs&quot; -SOURCE &#39;, input_raster,&#39; -GRID &#39;,input_gh,&#39; -RESAMPLING 0&#39;)) toc(log = TRUE) Grid coverages are calculated per class. output_types &lt;- &quot;analysis/Iwahashi_gh_.sgrd&quot; gh_grid &lt;- &quot;D:/people/Tim/grid/output/Goode_Homolosine_domain_10km.tif&quot; tic(&quot;Grid coverage per class&quot;) system(paste0(saga_cmd, &#39; grid_analysis 26 -CLASSES &quot;&#39;,input_gh, &#39;&quot; -COVERAGES &quot;&#39;,output_types,&#39;&quot; -TARGET_DEFINITION 1 -TARGET_TEMPLATE &quot;&#39;,gh_grid,&#39;&quot;&#39;)) toc(log = TRUE) Parameters are set. This includes the tag for this dataset and the different classes. A list of files is made for the coverages of all classes. type_list &lt;- list.files(path=&quot;analysis&quot;, pattern = &quot;^.*Iwahashi_gh_*.*.sgrd$&quot;, full.names = TRUE) dataset_tag &lt;- &quot;Iwahashi&quot; classes &lt;- data.table(name = 1:length(type_list), type = gsub(&quot;analysis/|.sgrd&quot;,&quot;&quot;,type_list)) Grid values for all classes are added to one data frame. # Data.table to append values to dt_total = data.table() # Set progress bar pb &lt;- progress_bar$new(total = NROW(classes), format = &quot;[:bar] :current/:total layers |:percent | :elapsedfull&quot;, width = 60) tic(&quot;Construct table with coverages&quot;) for (i in 1:NROW(classes)){ # Progress bar pb$tick() Sys.sleep(1 / 100) # Construct data.table with results type_raster &lt;- raster(type_list[i]) type_raster[type_raster == 0] &lt;- NA type_dt &lt;- as.data.table.raster(type_raster, xy = TRUE, centroids = TRUE, na.rm = TRUE) setnames(type_dt, classes$type[i], &quot;proportion&quot;) type_dt[,feature := paste(dataset_tag, classes$name[i], sep = &quot;_&quot;)] setcolorder(type_dt, c(&quot;x&quot;,&quot;y&quot;,&quot;feature&quot;,&quot;proportion&quot;)) type_dt[,area_km2 := 10^2 * proportion] dt_total &lt;- bind_rows(dt_total, type_dt) } toc(log = TRUE) The correct cell ID is added to each grid value. grid_table &lt;- fread(&quot;D:/people/Tim/grid/output/grid_table.csv&quot;, data.table = TRUE) ID_join &lt;- data.table::merge.data.table(grid_table, dt_total, by = c(&quot;x&quot;,&quot;y&quot;)) ID_join[,c(&quot;x&quot;,&quot;y&quot;) := NULL] The value table is saved and elapsed time is logged. fwrite(ID_join, file = paste0(&quot;output/&quot;,dataset_tag,&quot;_value_table.csv&quot;), row.names = FALSE, sep=&quot;,&quot;, dec = &quot;.&quot; ) toc(log = TRUE) # Time elapsed time_log &lt;- tic.log(format = TRUE) 4.5 World Reference Base Soil Groups (SoilGrids) Packages are automatically installed (if needed) and loaded from library. list.of.packages &lt;- c(&quot;rgdal&quot;, &quot;sf&quot;, &quot;raster&quot;, &quot;dplyr&quot;, &quot;data.table&quot;, &quot;progress&quot;, &quot;tictoc&quot;) new.packages &lt;- list.of.packages[!(list.of.packages %in% installed.packages()[,&quot;Package&quot;])] if(length(new.packages)) install.packages(new.packages, dependencies = TRUE) if(!(&quot;dtraster&quot; %in% installed.packages()[,&quot;Package&quot;])) remotes::install_github(&quot;ldemaz/dtraster&quot;) library(rgdal) library(sf) library(raster) library(dplyr) library(data.table) library(dtraster) library(progress) library(tictoc) A timer is set for the total calculation time and for each section seperately. tic.clearlog() tic(&quot;Total time&quot;) saga_cmd is linked to the R console. if(Sys.info()[&#39;sysname&#39;]==&quot;Windows&quot;){ saga_cmd = &quot;C:/Users/11026685/Downloads/saga-7.6.3_x64/saga-7.6.3_x64/saga_cmd.exe&quot; } else { saga_cmd = &quot;saga_cmd&quot; } system(paste(saga_cmd, &quot;-v&quot;)) #&quot;SAGA Version: 7.6.3 (64 bit)&quot; if succesful Working directory is set. setwd(&quot;D:/people/Tim/global&quot;) The raster is reprojected to Goode Homolosine input_raster &lt;- &quot;input/TAXNWRB_250m_ll.tif&quot; input_gh &lt;- &quot;input/SoilGrids_gh.tif&quot; tic(&quot;Reproject to Goode Homolosine&quot;) system(paste0(saga_cmd, &#39; pj_proj4 4 -CRS_PROJ4 &quot;+proj=igh +ellps=WGS84 +units=m +no_defs&quot; -SOURCE &#39;, input_raster,&#39; -GRID &#39;,input_gh,&#39; -RESAMPLING 0&#39;)) toc(log = TRUE) Grid coverages are calculated per class. output_types &lt;- &quot;analysis/SoilGrids_gh_.sgrd&quot; gh_grid &lt;- &quot;D:/people/Tim/grid/output/Goode_Homolosine_domain_10km.tif&quot; tic(&quot;Grid coverage per class&quot;) system(paste0(saga_cmd, &#39; grid_analysis 26 -CLASSES &quot;&#39;,input_gh, &#39;&quot; -COVERAGES &quot;&#39;,output_types,&#39;&quot; -TARGET_DEFINITION 1 -TARGET_TEMPLATE &quot;&#39;,gh_grid,&#39;&quot;&#39;)) toc(log = TRUE) Parameters are set. This includes the tag for this dataset and the different classes. A list of files is made for the coverages of all classes. type_list &lt;- list.files(path=&quot;analysis&quot;, pattern = &quot;^.*SoilGrids_gh_*.*.sgrd$&quot;, full.names = TRUE) dataset_tag &lt;- &quot;SoilGrids&quot; classes &lt;- data.table(name = 1:length(type_list), type = gsub(&quot;analysis/|.sgrd&quot;,&quot;&quot;,type_list)) Grid values for all classes are added to one data frame. # Data.table to append values to dt_total = data.table() # Set progress bar pb &lt;- progress_bar$new(total = NROW(classes), format = &quot;[:bar] :current/:total layers |:percent | :elapsedfull&quot;, width = 60) tic(&quot;Construct table with coverages&quot;) for (i in 1:NROW(classes)){ # Progress bar pb$tick() Sys.sleep(1 / 100) # Construct data.table with results type_raster &lt;- raster(type_list[i]) type_raster[type_raster == 0] &lt;- NA type_dt &lt;- as.data.table.raster(type_raster, xy = TRUE, centroids = TRUE, na.rm = TRUE) setnames(type_dt, classes$type[i], &quot;proportion&quot;) type_dt[,feature := paste(dataset_tag, classes$name[i], sep = &quot;_&quot;)] setcolorder(type_dt, c(&quot;x&quot;,&quot;y&quot;,&quot;feature&quot;,&quot;proportion&quot;)) type_dt[,area_km2 := 10^2 * proportion] dt_total &lt;- bind_rows(dt_total, type_dt) } toc(log = TRUE) The correct cell ID is added to each grid value. grid_table &lt;- fread(&quot;D:/people/Tim/grid/output/grid_table.csv&quot;, data.table = TRUE) ID_join &lt;- data.table::merge.data.table(grid_table, dt_total, by = c(&quot;x&quot;,&quot;y&quot;)) ID_join[,c(&quot;x&quot;,&quot;y&quot;) := NULL] The value table is saved and elapsed time is logged. fwrite(ID_join, file = paste0(&quot;output/&quot;,dataset_tag,&quot;_value_table.csv&quot;), row.names = FALSE, sep=&quot;,&quot;, dec = &quot;.&quot; ) toc(log = TRUE) # Time elapsed time_log &lt;- tic.log(format = TRUE) "],
["aggregating-value-tables.html", "Chapter 5 Aggregating value tables", " Chapter 5 Aggregating value tables After all calculations are done, the separate tables for all different layers can be combined into one large table. library(data.table) setwd(&quot;D:/people/Tim/global/&quot;) value_tables &lt;- list.files(path=&quot;output&quot;, pattern = &quot;value_table.csv$&quot;, full.names = TRUE) full_table &lt;- data.table() for (i in 1:length(value_tables)){ table &lt;- fread(value_tables[i], data.table = TRUE) full_table &lt;- rbind(full_table, table) } fwrite(full_table, &quot;output/full_value_table.csv&quot;,row.names = FALSE, sep=&quot;,&quot;, dec = &quot;.&quot;) The resulting table can be used in Marxan and looks like this: cell_ID feature proportion area_km2 3810092 GLWD_1 0.00368 0.368 3806588 GLWD_1 0.00272 0.272 3247606 GLWD_1 0.08608 8.608 3243741 GLWD_1 0.05472 5.472 3423450 GLWD_1 0.07504 7.504 3419671 GLWD_1 0.00816 0.816 3442310 GLWD_1 0.0064 0.64 3374182 GLWD_1 0.023392 23.392 3377986 GLWD_1 0.00368 0.368 3374183 GLWD_1 0.017728 17.728 In the feature column each dataset tag (i.e. GLWD) corresponds with one of the five datasets. The number or code signifies one class which can be looked up in the corresponding ‘legend’ table. "]
]
